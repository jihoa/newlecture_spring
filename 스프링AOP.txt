AOP 강좌 01강 - AOP(Aspect Oriented Programming) 

AOP라는 녀석을 이용해보려고한다. AOP는 스프링이 아니고 방법론이다.

우리가 지금까지한것은 Object Oriented Programming 객체지향 프로그래밍에만 관심이 있었다.
즉 사용자가 원하는 사용자 원하는 업무기반의 그런 로직만 관심을 가지고있었다.

우리가 체감하지못했던 코드가 들어가고있었다. 그 코드는 사용자의 요구사항이아니라 요구를 수반하기 위한코드이다. 
개발자나 관리자가 테스트하기위해 필요한코드들이있다. 그런녀석들을 관점에따라 나눠서 만드는것인데

관점 지향 프로그래밍 > 객체 지향 프로그래밍

Primary Concern은 관점에 해당하는것으로 객체로 만들어진다. 업무들은 메서드로 만들어진다.

객체지향프로그래밍으로 사용자의 관점에해당되는 내용을 잘만들었는데, 
로그처리라든지 (로그처리를 하는이유는 성능테스트라든지 사용자가 요구했던 권한이라든지 확인하기위해서 쓴다.)
보안처리라든지 트랜잭션이라던지 기타등등의 로직은 주업무는 아니지만 사용자가 요구하는 것을 수반하려면 필요하다.

옛날에는 로그를 처리하겠다라고 하면은 소스코드를 열어서 소스코드위아래에 코드를 입력하고 지워야되면 주석처리했다가 주석해제하고했다.
코드를 직접손대야해서 코드를 가지고있어야 크로스 커팅이 가능했다.

프로그램은 흐름이니까 굳이 소스코드에 꽂지말고 주업무는 주업무(Core Concern)대로 만들고 
로그를 꽂고 싶다하면 과거에는 무식하게 꽂았는데 지금은 (Cross-cutting Concern)proxy를 통해서 호출하게해서 스프링을이용해서 쉽게 뺐다꽂았다가 가능하다.

스프링으로 구현가능하지만 자바로도 구현이 가능하다.




-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

AOP 강좌 02강 - AOP 자바 코드 이해하기

지난시간에 AOP에 알아봤으니 코드로 어떻게 구현하는지 구현방식을 이해해보자

Core concern			 Cross-cutting Concern
업무로직코드				꽂아넣을 코드


Core Concern 코드없이 꽂아넣을수있도록한다. Proxy는 주업무를 가지고있는 녀석을 호출해준다.
proxy를 coreConcern 대신에 호출해줘서 넣어야할 Cross-cutting Concenr 코드를 작성할수있다.



-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


AOP 강좌 03강 - 순수 자바로 AOP 구현해보기

클래스를 생성하고 spring.aop라는 패키지에 담자 main함수도 추가하자.
aop라는것을 구현하기 앞서서 업무로직을 가진 클래스가 있어야한다.  Exam클래스를 복사해서 붙여넣고 spring.aop.entity라고 패키지만들자

-Program.java

package spring.aop;

import spring.aop.entity.Exam;
import spring.aop.entity.NewlecExam;

public class Program {

	public static void main(String[] args) {
		
		Exam exam = new NewlecExam(1,1,1,1);
		System.out.printf("total is %d\n", exam.total());
	}

}

여기까지는 업무를 사용자가요구하는 기능의 수준까지 다뤄봤다.

성능이 느리다는이야기가 들었으면 얼마나느린지 알아야하므로 체크해야한다.

-NewlecExam.java	
@Override
public int total() {
	long start=System.currentTimeMillis();
	int result= kor+eng+math+com;		// 사용자가 요구하는 기능의 수준
	try {
		Thread.sleep(200);
	} catch (InterruptedException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}

	long end = System.currentTimeMillis();
		
	String message=(end-start)+"ms 시간이 흘렀다.";
	System.out.println(message);
	return result;
}

옛날에는 이렇게 코드를 작성했었다. 소스코드에다가 이렇게 꽂아 넣었었다.
Proxy를 이용해서 Aop형식에 맞게 작성해보자

-Program.java

package spring.aop;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

import spring.aop.entity.Exam;
import spring.aop.entity.NewlecExam;

public class Program {

	public static void main(String[] args) {
		
		Exam exam = new NewlecExam(1,1,1,1);
		
		Exam proxy = (Exam) Proxy.newProxyInstance(NewlecExam.class.getClassLoader(), 	// 실질적인 객체를 로드하려고 객체정보를 첫번째매개변수로 넘겨줌
				new Class[] {Exam.class}, 						//인터페이스정보를 넘겨줘야하는데 복수형이어서 배열형태로 넘겨준다.
																//proxy 가짜라는 뜻도 가지고있다. 윗줄의 코드랑 똑같이 닮아있다. 하지만 곁다리업무를 가지고있다.
				new InvocationHandler() {
					
					@Override
					public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
						// 핸들러가 가지고있는 가장 중요한부분
						
						long start=System.currentTimeMillis();
						
						// 실제 업무로직을 꽂아 줘야한다. 실제업무를 담당하는 메소드를 실행하는 변수를 method라는 매개변수에 담겨있다.
						Object result = method.invoke(exam, args);		//실제 업무인 exam을 넣어준다. 	 호출한 메서드가 가지고있는 인자를 args로 넘겨준다. 모든형태의 값을 반환할수있게 Object형으로 형태를 지정
						

						long end = System.currentTimeMillis();
						
						String message=(end-start)+"ms 시간이 흘렀다.";
						System.out.println(message);
						
						return result;
					}
				});	// 마지막 은 핸들러라는 녀석을 꽂을수있다. 곁다리업무를 꽂을수있다. 인터페이스를 구현하는 클래스를  객체화하는 작업을해야하는데 별도의 클래스파일을 만들어야하는데 익명으로 익명클래스를 작성할것이다.
		
		System.out.printf("total is %d\n", exam.total());
	}

}
 aop는 곁다리업무를 만들고 필요에따라서 뺐다 꽂았다 할수있다.




-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
