Spring MVC (스프링 웹 MVC) 강의방향 안내

스프링 MVC의 두가지 버전

TomCat: 톰캣을 가지고 스프링없이 웹개발할수있다.
그떄는 web.xml에 설정했었는데 web.xml에다가 사용할라이브러리들을 썼다.
스프링을 쓰면 web.xml에 spring Dispatcher라는것을 쓴다.

Tomcat
Tomcat Configuration
-web.xml
	-Spring Dispatcher
	-MyBatis			//사용할 라이브러리들
	-Tiles			//사용할 라이브러리들
	-...


Tomcat
Tomcat Configuration
-web.xml
	-Spring Dispatcher
	


Spring Web
Spring Configuration
	-Servlet		|
	-Service		|
	-Security		}- XML,Annotation,java 로 설정한다.
	-MyBatis		|	
	-Tiles		|	
	-...

스프링 MVC는 프론트 컨트롤러를 제공한다.

web.xml에다가 spring Disapatcher를 올리면 스프링이 모든것을 관리하려고한다. Spring Configuration으로 mybatis,tiles등등이 옮겨지게된다.

설정하는 방법이 버전에따라서 달라졌다. 주로 현재 전자정부프레임은 xml+annotation 조금이고 현재는 Java로 Configuration하고있다. 
스프링을 가지고 개발하다보면 다 다른방식으로 개발해서 구분이 잘안되고 설정하는 것이 버전에따라서 달라서 

설정을 도와줄수있는 스프링부트가 나왔다. spring mvc를 대신하는것이아니고 설정을 모아서 편하게 설정할수있는 부가적인 프레임 워크이다. 스프링에다가 스프링부트를 얹으면 복잡한설정을 피할수있다.


Spring Boot
Starter Configuration	//Starter는 필요한것들 (servlet,service,security)등등을 묶어서 라이브러리로 가지고있다.
application.properties( 설정파일)		//일반적으로 이걸더 많이 쓰인다.
또는
YAML(설정파일)



-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 01 - Spring MVC란

스프링이 제공하는 mvc가 무엇인지 알아보는 시간을 가지도록 하자

model1:컨트롤러가 개념적으로 존재, 그것을 출력을 담당하는 부분이 하나로 뭉쳐짐
 model2: 두개를 나누고, 컨트롤러는 서블릿으로 구현, jsp를 템플릿화면으로 뷰로 사용

dispatcher를 이용해서 포워딩을 했다. 모든 컨트롤러는 dispatcher기능을 다 구현해야하고 모든 컨트롤러에다가 가지고있는것은 비효율적인것 같다.
그래서 순수하게 컨트롤러 기능만 POJO로 구현할것이다. (Plain old java object) 평범한 자바 객체

컨트롤러가 빠진 Dispatcher가 남는다.
Dispatcher는의 기능은 view로 포워딩하는 기능이기때문에 기능이 거의다 똑같다. 그래서 Dispatcher하나만 둘수있다.

1. Dispatcher가 controller에게 사용자에게서 온 요청을 전달하고
2. 요청을 해서 결과물을 받아서 View로 전달

그런데 이 과정이 간단하지만은 않다. Dispatcher의 역할이 굉장이 중요하다.
사용자의 요청을 받는다는것은 단순하게 요청을 라우팅하는 역할이아니라 사용자가 전달하는 입력값이있으면 입력값을 Controller에게 사용하기 쉽게 포장해서 줄수도있다.
쉽게 포장해서주면 지금까지 했던것 servlet 이용해서 get 파라미터 이렇게 이용하는게 아니라 서블릿의 기능을 다차단할수있다.
Controller 에 기본적으로 사용할수있는 String int 등등으로 전달이 가능하다.

두번째는 단순하게 기본형으로 전달하는게아니라 어떤데이터를 개체화하는데 notice형 student형 등등으로 담아줄수있다. 서블릿라이브러리를 하나도 쓰지않고 입력을 처리할수있거나
Controller에서 말해놔서 view에 전달할때도 Controller에는 dispatcher기능이없다. 리턴할때 어떤 뷰페이지가 필요하다 라는 정보만 알려주면 Dispatcher가 View를 호출하면서 서블릿 기능을 Dispatcher로 한정할수있다.

이게바로 Dispatcher를 따로 분류하는 이유이다.

 Dispatcher와 Controller 결합력을 낮추게 함으로써 다른환경에서도 사용할수있게끔 하려고 한다.


Dispatcher를 만드는게 중요한데 Dispatcher만드는것을 스프링이 제공했다. 프론트컨트롤러를 잘만들게되면 톰캣과 이별할수도있다.



서블릿 디스패처 스프링이 제공한다.
모든 url요청이 오는데 적절하게 알맞은 컨트롤러에게 전달해야가기때문에  url을 어떤 controller가 처리할지를 가지고있어야한다. 설정파일이 필요하다. 과거에는 web.xml에서 설정하거나 annotation으로 설정했지만 
현재는 servlet.xml에 매핑정보를 쓰게된다.
스프링을 이용해서 컨트롤러를 이용하겠다는 것이다.

스프링 mvc는 라이브러리를 쓰는것인데 spring-webmvc에 있다.


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 02 - 실습환경 준비하기

스프링MVC를 실습을 통해서 MVC라이브러리를 쓰려면 실습환경을 준비해야한다.
실습환경
톰캣
jdk

개발환경도구
Spring에서 제공하는 개발환경도구

브라우저를 열고 spring.io접속 
그리고 사용할것은 spring Tools 4 for Eclipse를 다운하자 이 도구를 꼭 사용해야하는건 아니다. 설치하지않아도 라이브러리를 쓰면된다.
최신버전을 다운로드하자

다운로드해서 압축을 풀고 contents.zip을 잘라내기해서 tools(도구들 넣는 폴더) 에다가 sts-4.10.0.RELEASE를 넣어준다.

톰캣도 최신버전을 다운로드하자. 압축되있는 버전

부트를 사용하면 톰캣도 없어도 된다.
부트를 가지고 개발해도 좋으나


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 03 - 메이븐을 이용한 기본 웹 프로젝트 생성하기


지난시간에 spring web project를 만들기위해 실행환경으로써 톰캣을 다운받았고, 프로젝트를 개발하기 위해서 사용되는 스프링툴스를 받았다.
이것을 이용해서 빈프로젝트(스프링 배제하고 ,maven기반) 으로 만들고 다음시간에 spring을 다음시간에 얹는 작업을 할것이다.

프로젝트를 만들때 Create new Spring Starter Project는 스프링 부트를 기반으로 해서 만드는 프로젝트인데 스프링에 스프링부트를 얹은녀석이다.

오늘은 기본적인 웹프로젝트를 만들것이다. perspective -> javaEE-> Create a Maven project

Create a simple project(skip archetype selection) 체크
Use default Workspace location 체크

다음
packaging: war 로 변경

만들어지면 pom.xml에 빨간줄이 그어진다.  에러메세지는 web.xml이 없어서 에러가난것이다. web.xml 은 어디에 둬야하는가?
webapp안에 webinfo를 만들고 그안에다 둘것이다.


apache-tomcat-9.0.38/webapps/ROOT/WEB-INF 를 복사해서 src/main/webapp 에다가 넣어주면 된다. 이렇게 붙여넣어주면 pom.xml에 에러가 사라진다.

java resources를 보면 jdk가 1.5로 되어있다. pom.xml 에서 overview 로 가서 properties에서 create에서 Name: maven.compiler.source Value:1.8
로적어주면 추가가된다. 그리고 복사해서 붙여넣어서

 <maven.compiler.source>1.8</maven.compiler.source>		//1.8쓸거고
 <maven.compiler.target>1.8</maven.compiler.target>		//대상도 1.8버전이다.
그리고 보면 안바뀌어있다. pom.xml에 변경사항이 생긴다면 프로젝트에서 오른쪽 클릭을하고 maven-> update Project라는 버튼을 누르자
update를 하고나면 제대로 바뀌었다.

jsp 파일을 추가 할것인데 preference->Web->JSP Files
Korean,EUC-KR을 ISO 10646/Unicode(UTF-8)로 바꿔주도록 하자

html,css도 똑같이 바꿔주자

프로젝트->Properties->Resource-> 인코딩을 UTF-8로 바꿔주자

web-app 아래에 jsp파일을 추가해주면에러가난다. 왜 에러가나냐면? jsp 관련된 톰캣라이브러리가 없어서 그렇다.

pom.xml에 추가할것인데 구글에서 maven tomcat api 를 검색해서 톰캣 버전에맞게 클릭을 하면 코드가 뜨는데 그것을 복붙해주면된다.

-pom.xml
	.....	
	.....
  <packaging>war</packaging>
  <dependencies>
  <!-- https://mvnrepository.com/artifact/org.apache.tomcat/tomcat-api -->
	<dependency>
    	<groupId>org.apache.tomcat</groupId>
    	<artifactId>tomcat-api</artifactId>
    	<version>9.0.41</version>
	</dependency>
  </dependencies>
  <properties>
  	<maven.compiler.source>1.8</maven.compiler.source>
 	<maven.compiler.target>1.8</maven.compiler.target>
  </properties>
</project>

이렇게 하면 JSP파일에 에러가 사라진다. 
그리고 JSP 를 실행하면 실행환경이 구축이 안되어있다. apache Tomcat9.0을 설정하자
그리고 톰캣폴더를 지정해주자

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 04 - Dispatcher Servlet 라이브러리 설정하기

maven 프로젝트를 만들어봤는데 그 프로젝트 위에 maven을 얹어 보도록해야겠다. 얹는다는것은 스프링이 프론트컨트롤러를 제공해
 그 프론트 컨트롤러 역할은 무엇인지 알아보는것도 중요하다.

Dispatcher에다가 Servlet관련된것을 넣고
Controller에 POJO를 만들것이다.

Dispatcher는 어떻게 구할것이냐? spring-webmvc 라이브러리안에 DispatcherServlet 이라는 클래스를 다운로드해야한다.
maven을 이용하게될경우 다운로드할경우 pom파일로 다운이 가능하다.

다운로드방법
1. 페이지방문해서 다운로드
2. window 메뉴-> show view-> maven repository-> Global Repository-> Rebuild index 또는 Update index 둘중에 하나를 선택하면 원격에있는 라이브러리를 가져온다.

원격에있는 저장소에 있는 라이브러리 목록으로 가져올수있다. 라이브러리를 가져오는것이 아니다.

Rebuild해놓으면 꽤 시간이 걸린다.  다음부터 다운받을 일이있으면 원격저장소에 index를 가지고 쉽게 추가할수있다.
Dependencies라는 탭이있다. Dependecies에 보면 유저인터페이스가 그래픽하게 보여진다.
Add를 눌러서 검색이 가능하다. 검색을 해서 라이브러리를 다운받을수 있는데 검색에있는 목록이 원격에있는게 아니라 인덱싱을한 내용가지고 검색을한다.

다운로드하면 원격에서 다운로드해서 가져온다.
일단은 인덱싱이 안되었기 때문에 페이지에가서 다운로드 받자.
https://mvnrepository.com 에서 spring framework 검색-> spring web클릭하고 최신버전을 다운해도 가능하지만

Spring Web MVC를 다운받으면 Spring Web이 필요하다 필요하게되면 자동으로 다운받아지니 Spring Web MVC의 최신버전을 다운받자
다운로드가 다되면 Libraries를 열어보면 JRE Maven Dependencies 두개가 있다.

pom.xml에 설정했던내용을 Maven Dependencies에 포함이되어있다. Maven을 쓰는 가장 중요한 이유는 하나를 다운받으면 그것에 필요한 Dependencies를 다운받아준다는것이다.

지금우리는 tomcat-api 와 spring-webmvc 두개만 다운로드했었는데 maven이 필요하니까 계층적으로 하위 라이브러리까지 다운로드해줬다.

maven을 쓰지않고 직접쓴다면 관련성있는 라이브러리 찾는것도 굉장히 오래걸린다. maven 덕분에 굉장히 쉽게 라이브러리 추가가 가능해졌다.
spring-webmvc 아래 servlet아래에 DispatcherServlet 이라는 클래스에다가 Copy qualified name을 하게되면 패키지명과 클래스명을 한번에 복사가 가능하다. 


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 05 - dispatcher-servlet.xml 파일

지난시간에 스프링을 사용하기 위한 라이브러리를 다운받아놨는데 그것을 이용해볼것이다.
그러기위해서는 스프링에서 제공하고있는 컨트롤러가 있는데 그 컨트롤러와 프론트 컨트롤러다. 그것을 사용하기위해 가장 중요한것은
dispatcher-servlet.xml이라는 xml파일이다.
 
xml파일의 의미와 용도를 알아보자

기본적인 mvc는 꼭 spring이 있어야하는건 아닌데 스프링없이 mvc를 구현하려고하면 컨트롤단이있어야하고 컨트롤 단에서 만들어낸 데이터를 가지고 화면을 출력해야한다.
index.jsp를 view라고 하고 모델을 컨트롤러가 심어서 전달을 해주면 모델데이터를 출력하는것을 해보자.

-index.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
	<h1>Hi ${data}</h1>
</body>	
</html>

기본적으로 컨트롤러를 만든다고 하면 그냥 클래스를 만들어서  extends HttpServlet 해도 되는데 
서블릿의 기능을 분리해서 누가 가져가냐? spring-mvc에서 Dispatcher-servlet.xml이 그역할 가져갈것이다.

컨트롤러를 POJO로 만들고 Dispatcher는 만들어져있는거라서 annotation으로 url 매핑을 할수가없다.

Dispatcher에다가 url매핑을 해야하는데 어디서하냐면 web.xml에다가한다.

-web.xml

<?xml version="1.0" encoding="UTF-8"?>

<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
  version="4.0"
  metadata-complete="true">

	<servlet>	<!--서블릿 설정할 클래스는 dispatcherServlet인데  -->
		<servlet-name>dispatcher</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
	</servlet>
	<servlet-mapping><!-- 서블릿을 사용자가 요청할 수 있게끔 하는 매핑 주소가 있어야한다.  -->
		<servlet-name>dispatcher</servlet-name>
		<url-pattern>/</url-pattern><!-- 주소를 쓰는데 프론트 컨트롤러여서 모든 /로 시작하는 url을 받을것이다. 각각의 포조클래스를 분배해주게 되어있다. -->
	</servlet-mapping>

  <display-name>Welcome to Tomcat</display-name>
  <description>
     Welcome to Tomcat
  </description>
</web-app>

이렇게하면 서비스 설정 끝난것이다.

Hi라는 페이지가나온다. 우리가 원했던건 프론트 컨트롤러 를 만들었다. 모든 주소를 받아들이고 어떠한 요청이와도 프론트컨트롤러가 매핑하지않은 url은
url은 나오면 안된다. 이거는 안되는것이다

뭐가잘못된것이냐면

<url-pattern>/</url-pattern> 모든것이 통과한다. 
<url-pattern>/*</url-pattern>//어떤 url도 허락하지않으면 통과하지않는다. 로 바꾸고 실행을 해보자

web-INF안에 Dispatcehr 서블릿이 없다는 에러가 나온다.


disapatcher를 이용하려고 하는데 서블릿으로 설정했고 모든 URL에 대해서 받겠다. index.jsp라고 요청이왔는데 적절한 url에 맞는 리소스를 배분해줘야하는데
매핑정보가 필요하다. *-servlet.xml 이 약속되어있는 위치에 있어야한다. 기본위치는 -servlet.xml이 있어야한다.
설정파일이없으니까 매핑할수도없었다.

그렇다면 WEB-INF/dispatcher-servlet.xml 파일을 만들자.

그리고 이파일에다가는 무엇을 넣어야할까 다음시간에 알아보자

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 06 - 스프링 컨트롤러 IndexController 작성하기

지난시간에 스프링이 제공하는 mvc를 지원한 라이브러리인 dispatcher 라이브러리 그 녀석이 사용하는 설정파일이있다.
그것이 바로 dispatcher-servlet이라는 파일인데 그것을 작성하고 indexController를 POJO 기반으로 스프링의 도움을 받아서 작성해보도록할것이다.

어떤 구문으로 어떻게 작성할수있는지 알수없다. dispatcher를 만든 스프링에서 레퍼런스를 참조해야한다.

https://docs.spring.io/spring-framework/docs/

core를 클릭하고 

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="..." class="...">  // beans:어떤 클래스를 설정하면 얘를 객체화해서 스프링컨테이너에 담게 된다. id는 class를 꺼내서 사용할떄쓰는건데 mvc는 다르게 사용한다 . url을 쓴다.
        <!-- collaborators and configuration for this bean go here -->
    </bean>

    <bean id="..." class="...">
        <!-- collaborators and configuration for this bean go here -->
    </bean>

    <!-- more bean definitions go here -->

</beans>
를 복붙해서 넣어주면된다. 

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="/index" class="com.newlecture.web.controller.IndexController">		//mvc는 스프링이기떄문에 컨테이너에 담겨진것을 사용한다. /index라는url 요청이오면 com.newlecture.web.controller.IndexController를 객체화해서 호출한다. 
        <!-- collaborators and configuration for this bean go here -->
    </bean>

</beans>

남아있는 spring에 dispatcher라는 클래스(프론트 컨트롤러)가 컨테이너에서 꺼내가지고 얘가 가지고있는 기능을 호출해주는것만 남았는데
그걸 하기위해서 두가지를 해야한다. url 과 컨트롤을 매핑한 정보를 id라는 것을 이용해서 url을 쓰게 되어있는데 이게 bean이라고 하는걸 등록이 되면 컨텐츠가 담겨지는것이다.
Controller에는 POJO 형식으로 만들어놓은 녀석들이 있는데,  Dispatcher에서 Controller를 사용하려면 약속되어있는 어떤게 있어야할것같다.

사용자가 index요청을 했으면 요청에 수반할수있는 함수가있어야한다. 그함수명은 약속이되어있어야하나?
그렇다 그것은 handleRequest이다. Dispatcher가 제공하는 약속이 인터페이스가 있다. 그것을 구현해야한다.

약속을 수반하는 인터페이스를 구현해야한다.


모델앤뷰라는 녀석이 반환되면 dispatcher에게 가고 dispatcher가 포워딩해서 뷰를 찾아서 모델을 전달  view에서 그모델을 사용해서 사용자에게 출력한다.

실행해보면 404에러가 난다. 톰캣의 어노테이션쓸려면 매핑주소를 읽어서 요청해주는데, 톰캣이 모르는  POJO클래스니까 클래스가아니까 소스코드로 반환하는일이 발생한다.
우리가 원하는건 url매핑된 정보이다. 그래서 http://localhost:8080/webprj/index 를 요청하면 잘될까?

안된다. 왜 안되냐면 web.xml에 보면 url매핑했던부분 <url-pattern>/*</url-pattern> 이 문제다.
*를 쓰면 포워딩이든 get요청을 하든 DispatcherServlet를 다시거쳐가야한다. index를 거쳐서 com.newlecture.web.controller.IndexController를 요청을 했는데
dispatcher-servlet.xml 에 index.jsp의 내용이 없어서 에러가 발생한다. 그래서
<url-pattern>/</url-pattern> 별을 뺀다.

DispatcherServlet를 거치기는 하지만 리소스에서 찾아보지만 없으면 리소스에 직접 요청하게해준다. 잘 나왔따. 처음부터 그럼 별을 빼면되는데 왜안뻈을까 다음시간에 알아보자

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 07 - View 페이지를 위한 위치

index 컨트롤러를 만들어봤는데, 그러면서 web.xml에서 url 매핑에대해서 이야기했는데, *를 지우면 문제가 발생하는것도 이야기했었다. 그 이야를 해볼것이다.

*을 지우면 문제가된다. controller가 있고 view가 있다. controller와 view가 분리되어 있을경우 실제 어플리케이션은 하나이다.
사용자요청이 왔을떄 controller따로 view 따로 정할수 있는것이아니라 무조건 controller만 요청하게 해야한다. 프로그래밍은 절차가 중요하다.

실행되는 순서로봤을때 controller가 위고  view 아래이다. 그렇다면 사용자가 view만 요청하면 안되는것이다. 원래하나인데 유지관리 편하게하기위해 자바코드를 뺀것이다. 

index.jsp 에서 ctrl+F11눌러서 실행해보면 실행이된다. 이러면 문제가 있는것이다. 사용자가 얘를 요청할수 없게끔 해야한다.
그렇다면 <url-pattern>/*</url-pattern> 을 다시 복구할것인가 이것도 문제가있다. mvc를 구현한사람들은 어떻게 해결하냐면
view페이지를 요청할수 없게끔 숨겨놓는 작업을 한다. 사용자가 직접요청할수없는 영역이있다. 

WEB-INF 안에 view라는 폴더를 만들자(폴더이름 상관없음) 그리고 index.jsp를 view라는 폴더안에다가 넣게된다면 사용자가 직접적으로 index.jsp를 요청할수 있는 방법이 없다.
얘는 비공개영역이라서 접근할수없다.
그렇다면 컨트롤러에서도 이용할수 없으면 안되니까 다행스럽게도 컨트롤러에서는 요청할수있다.클라이언트 쪽에서 요청하는것이 불가능한것이지 서버쪽에서 파일요청은 가능하다.

-IndexController.java

mv.setViewName("index.jsp");
부분을
mv.setViewName("/WEB-INF/view/index.jsp");
로 바꿔주면된다. 이렇게 설정하면 긴문자열이 마음에 안드는데 다음시간에 설정하는 방법을 알게될것이다.
이제 view페이지는 컨트롤통해서만 요청이가능하다.
잘 나온다.

mvc를 가지고 프로그램만들떄 혼란스러운것은 404가 많이난다는것이다. 

-IndexController.java
mv.setViewName("/WEB-INF/view/index.jsp"); 		->		mv.setViewName("WEB-INF/view/index.jsp");

에러가 나지않는다. index가 가지고있는 url에 맞춰서 상대적인 url을 갖는것이다.

-dispatcher-servlet.xml
 <bean id="index" class="com.newlecture.web.controller.IndexController">  	=>	<bean id="/aa/index" class="com.newlecture.web.controller.IndexController">  
실제로 aa라는 폴더가 존재하지않는다.파일도없다.  com.newlecture.web.controller.IndexController의 이름일 뿐이다.

WEB-INF/view/index.jsp 상대경로로 적었는데 이렇게 쓰면 현재 이 컨트롤러가 가지고있는 url은 http://.../aa/index로 본다. 그래서 WEB-INF와 같은 위치에 있다고보고
그래서 /를 뺴면  http://.../aa/ 에서 WEB-INF를 찾는다. http://.../aa/WEB-INF

그러니까 오류가 발생한다. view를 찾을떄는 절대경로를 쓰면된다. /에서 WEB-INF를 찾게된다.
상대경로쓰면 힘드니 절대경로 쓰는게 낫다.

<bean id="/index" class="com.newlecture.web.controller.IndexController">  		//여기도 /를 붙여야한다.
        <!-- collaborators and configuration for this bean go here -->
 </bean>


http://localhost:8080/webprj/index 여기서 webprj는 무엇일까? 프로젝트명이다. 프로젝트명은 원래 들어가면안된다. 컨텍스트명을 붙인것이다. 현재 프로젝트가 컨텍스트명을 가질필요가없다.
프로젝트 오른쪽클릭-> properties-> Web Project Settings
컨텍스트명을 /로 변경할것이다. 컨텍스트명을 변경하면 Servers에서 SNAPSHOT을 지워야한다.

이제 Index Controller를 열어서 실행하면 될까 안될까? 안된다. 이클립스가 브라우저를 띄워준다. 이클립스가 적당한 요청 url을 입력해주면서 창을 띄주는데
이제 그런것이 불가능해진다. 약간 편법을 쓰게되면 index라는 파일이 현존하는것이아니다. 파일이없으니까 src에 main에다가 매핑주소가 똑같은 빈파일을 만들어보자
실행이된다. index 빈파일을 요청한것이 아닌데 이클립스한테 요청하면 이클립스는 파일명과 동일한 이름의 url을 입력해준다.
http://localhost:8080/index 그런데 하필 동일하게 매핑된 주소가 있는데 컨트롤러가 우선순위가 더 높기 떄문에 컨트롤러에 부합되는 디스패치가 일어나서 된것이다.


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 08 - ViewResolver 사용하기

지난시간에 뷰페이지를 WEB-INF안에 view로 옮겼다. 그렇게 함으로써 뷰페이지를 찾는 방법이 복잡해졌다. 왜냐면 WEB-INF를 붙여야하고 view라는 폴더도 있으니까
그래서 복잡해졌기때문에 쉽게 찾을수 있도록 ViewResolver라는 녀석을 사용할것이다.

-IndexController.java

ModelAndView mv = new ModelAndView("/WEB-INF/view/index.jsp");

컨트롤러 만드면서 view페이지를 WEB-INF에 둠으로써 찾는방법이 복잡해진것이다. 그래서 보면 지난시간에 다뤘던 내용에서는 ModelAndView를 기본생성자로 만들고
jsp라고하는 페이지가 있는 그 경로가 setViewName이라고하는 세터를 이용해서 설정했는데 오버로드된 생성자 이용해서도 설정을 많이한다.(오버로드 방법을 더 많이씀)
1. 세터 설정방법
ModelAndView mv = new ModelAndView();
mv.setViewName("/WEB-INF/view/index.jsp");

2.오버로드 생성자 설정 방법
ModelAndView mv = new ModelAndView("/WEB-INF/view/index.jsp");

경로를 쓰는방법이 복잡해졌다. IndexController 하나에서만 쓰는게 아니라 다른것도 써야한다.
어떻게 해야하냐면 /WEB-INF/view/    .jsp 를 빼고  view페이지인 index만 쓸수있게해야한다.

-IndexController.java

ModelAndView mv = new ModelAndView("index");

그러면 모든컨트롤러가 깔끔하게 쓸수있다. 그러면 index만 반환해서 디스패처가 받으면 그런리소스가 없으니 404나는게 아니냐?
전달된거에다가 /WEB-INF/view/    .jsp 를 붙여서 찾게 해주는것이 viewResolver이다.
앞뒤에 붙여서 실제적인 view페이지를 찾을수있게 해주는 능력자이다.

dispatcher-servlet.xml 에 ViewResolver를 설정하도록하자.

org.springframework.web.servlet.view.InternalResourceViewResolver 를 스펠링이 틀릴수가 있으니 java파일에서 ViewResolver를 찾아서 import 시키고 그것을 복붙해오자

-dispatcher-servlet.xml 

<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
	<property name="prefix" value="/WEB-INF/view/"></property>
	<property name="suffix" value=".jsp"></property>
</bean>

해주면 제대로 동작한다.


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 09 - HTML 파일 설정하기

지난시간까지 스프링이 제공하고있는 mvc 웹개발도구인 dispatcher를 설정해봤다.
이 강의 부터는 기본적으로 페이지를 가지고 mvc를 개발해야하므로 기본적 html 파일을 설정하는법을 알아보자

newlecture 사이트에서 html파일을 다운받아서 webapp 아래에 넣었다.

이미지와 css는 출력이 되지를 않는다 다음시간에는 어떻게 해결할것인지 알아볼것이다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 10 - 정적파일 서비스하기

이미지파일을 보려고했더니 페이지에서 볼수없었다. 왜냐면 서블릿에서 제공하는 디스패처라는 녀석의 장난 때문이다.
한번 그 내용이 어떤 내용인지 어떻게하면 사용할수 있을지 보자

스프링이 정적인 파일을 제공하지 않도록 막고있기 때문이다. html, image는 막아 놓았지만, jsp는 열어놨다.
그래서 예시로 webapp아래에 jsp를 놓고 실행해보니 잘 실행된다.
하지만 예시로 webapp아래에 image를 놓고 실행해보니 실행 안된다.

그니까 설정을 할때 web.xml에다가 설정을 했었을때

<url-pattern>/*</url-pattern>		// jsp 까지 막겠다.
<url-pattern>/</url-pattern>		// 기본적으로 정적인 파일을 막는데 예외로 jsp는 안막음

그럼 정적인 파일은 어떻게 서비스할것인가?

<mvc:resources location="/images/" mapping="/images/**" />		// 사용자가 image로 시작하는 mapping된 url요청하면 location 디렉토리에서 찾게 해주겠다.

이렇게해서 숨통을 열어 놓는것이다.

<mvc:resources location="/images/" mapping="/images/**" />
<mvc:resources location="/js/" mapping="/js/**" />
<mvc:resources location="/css/" mapping="/css/**" />

			↓	이렇게 할수도있지만 일반적으로는 아래와 같이한다. 리소스 폴더를 만들어서 때려넣는다.

<mvc:resources location="/resource/" mapping="/resource/**" />


-dispatcher-servlet.xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:mvc="http://www.springframework.org/schema/mvc"
    	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    	xsi:schemaLocation="http://www.springframework.org/schema/beans
        		https://www.springframework.org/schema/beans/spring-beans.xsd
        		http://www.springframework.org/schema/mvc				// 아래의 스키마파일에 이름을 정의 함 이녀석의 이름은 xmlns:mvc를 따서 namespace는 mvc:로 쓴다
        		https://www.springframework.org/schema/mvc/spring-mvc.xsd">		//스키마파일 :태그로 어떤 명령어를 넣는데 페이지 내의 쓸수있는 태그를 정의하는 파일


	<bean id="/index" class="com.newlecture.web.controller.IndexController"/>
	
	<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<property name="prefix" value="/WEB-INF/view/"></property>
		<property name="suffix" value=".jsp"></property>
	</bean>


	<mvc:resources location="/resource/" mapping="/resource/**"></mvc:resources>	//resource를 정의할때 쓰는 mvc, 스프링 디스패처가 이 명령을 읽게되면 mvc 설정을 따라서 거기에 맞게 행동을 한다.
										// 하위폴더에 대해서 모든 이름 /**
									
이렇게하면 resource 폴더 아래에 있는 정적인 파일들이 잘 표시가 된다.
서비스를 할때 resource 파일을 어떻게 할것인가? resource 기반으로 요청을 하면 /resource/image/logo.png 라고 해야한다.
그래서 요즘에는

	<mvc:resources location="/static/" mapping="/**"></mvc:resources>		//정적인 파일이 마치 루트에 있는것 처럼하고 static파일은 모아놓는게 좋으니 static을 주소로 지정한다.

html 폴더를 이름을 static으로 변경하고 전강의에서 뺐었던 css,js,image파일을 다시 집어넣었다.
static은 서버코드가아니라 클라이언트에게 그냥 전달되는 정적인 그런파일들만 전달한다. 동적인 파일들은 webapp아래에 그냥 둘수있다.


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 11 - 공지사항 컨트롤러 추가하기

지난 시간까지는 스프링 mvc를 개발하기 위한 기본설정을 해봤고, 이제부터는 본격적으로 스프링을 이용해서 mvc 형태의 웹 개발을 하기위해서
컨트롤러 몇개를 추가할 예정이다.

static파일을 준비했는데 html파일이 들어가있다. detail.html list.html 의 내용을 복사해서 webapp/WEB-INF/view/notice 아래  detail.jsp 와 list.jsp로 만들었다.
이제 컨트롤러가 필요한데 com.newlecture.web.controller 패키지 아래에다가 notice에 관련된 컨트롤러를 추가하도록 하자
com.newlecture.web.controller 아래에다가 com.newlecture.web.controller.notice 라는 패키지를 만들자

새로운 jsp 파일만들면 해야할것들

1. Controller 작성
2. dispatcher-servlet에서 url 매핑

 <bean id="/notice/list" class="com.newlecture.web.controller.notice.ListController"/>

/notice/list는 실제로 존재하는 파일명이나 디렉토리 명이 아니다. com.newlecture.web.controller.notice.ListController를 호출하기 위해쓰는 이름

index에서 고객센터를 눌러서 이동해보니 url이 http://localhost:8080/notice/list.html 로 나왔다 왜 그럴까?

index.jsp에서
 <li><a href="/notice/list.html"></li>
부분이 있는데 list.html을 호출해서 그렇다. 컨트롤러의 url은  html이 빠진 /notice/list 가 되어야한다.

모양은 비슷해보이지만 컨트롤러를 통해서 오는것과 html통해서 왔다는 점에서 차이점이 있다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 12 - Detail 컨트롤러 추가와 View 페이지 집중화의 필요성

페이지마다있는 집중분모를 집중해야한다 왜냐면 헤더부분을 수정하려면 모든페이지를 다 다니면서 헤더부분의 내용을 수정해야 하기때문이다.
그래서 다음시간에서 페이지마다 나타나는 공동 사항에대해서 타일스를 사용할것이다. maven library에 포함할것이다. index화 되어있는것을 쓸것이다.


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 13 - 페이지 공통분모 집중화

페이지를 어떻게 나누고 집중하는지 알아보자

사이트를 만들게되면  어떤 컨텐츠를 가지고있는 내용은 링크를 타고 맨 끝의 페이지에 존재하게 된다.
그 끝에있는 페이지는 목록,자산,수정 등 페이지이다.

위로올라가면 올라갈수록 전체 사이트에대한 링크들을 가지고있을것이다. 페이지마다 공통으로 가지고있는 영역이 있을것이다.
header,footer 등등

같은것이라면 분리해야한다. 페이지에서 공통으로 있는것이면 분리해서 링크에서 쓰는방법을 가져와야한다.

header를 공통 페이지로 만든다면 
header.jsp에 공통되는 부분에 만들어 놓고, 
<jsp:include page="inc/header.jsp"/> 라는 jsp태그를 이용해서 링크해서 쓸수있도록 하면된다.

하지만 include 방법을 사용하지는 않을것이다. 왜냐면 문제점이 있기때문이다.

페이지마다 include하는것이 중복된다. 이것마저도 불편해보여서 새로운페이지를 추가하겠다 하면 include라는 jsp가 제공하는 기능을 사용하지않고
tiles라는 외부라이브러리를 사용할것이다. tiles를 이용하게된다면 공통되는 부분을 layout으로 만들고 그렇지않은 부분은 contents로 만들것이다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 14 - 페이지 모듈 분리하기

페이지 집중화를 위해서 페이지에서 공통으로 나타나는 부분과 그렇지 않은 부분을 나누는 작업을 할것이다.

index.jsp에서 header라는 부분을 분리하자

1.view 폴더 밑에 include라는뜻에 inc 폴더를 생성
2. header.jsp 파일을 생성하고 header를 그대로 가져와서 붙여넣기
3.  같은방법으로 footer도 생성


공통분모가 페이지마다 있으면 집중화를 위해서 빼야한다.

aside와 layout 등등도 따로 뻈다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 15 - Tiles 지시서 작성하기

지난시간에 페이지에서 나타나는 공통분모를 inc에다가 묶어놨다. tile를 이용해서 엮어 내는 작업을 해야하는데, 지시서를 작성해야한다. 

tiles를 사용하기위해서 apache.org를 들어가도록하자.

tiles는 페이지를 합쳐주는 라이브러리인데 프론트로 옮겨가고있는 상태여서 tiles는 은퇴했다고 뜬다.
이거를 배워야할까? 현재에는 백이나 프론트에서 페이지를 합칠수있기때문에 일단 배워두자

/WEB-INF/tiles.xml에다가 공식문서가 적힌대로 설정하도록하자.

-/WEB-INF/tiles.xml

<!DOCTYPE tiles-definitions PUBLIC
       "-//Apache Software Foundation//DTD Tiles Configuration 3.0//EN"
       "http://tiles.apache.org/dtds/tiles-config_3_0.dtd">
<tiles-definitions>
  <definition name="myapp.homepage" template="/layouts/classic.jsp">
    <put-attribute name="title" value="Tiles tutorial homepage" />
    <put-attribute name="header" value="/tiles/banner.jsp" />
    <put-attribute name="menu" value="/tiles/common_menu.jsp" />
    <put-attribute name="body" value="/tiles/home_body.jsp" />
    <put-attribute name="footer" value="/tiles/credits.jsp" />
  </definition>
</tiles-definitions>

위치는 달리해도되지만 기본이 여기라고하니까 여기다가 두도록하자.

-ListController.java

public class ListController implements Controller{

	@Override
	public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
		ModelAndView mv = new ModelAndView("notice.list");	// 컨트롤러가 notice.list로 반환하면 이걸가지고 tiles를 호출해서 페이지를 조합해서 반환할것이다.	
	}

}


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 16 - 레이아웃 페이지 만들기와 Tiles 라이브러리 설정하기

tiles가 사용하게될 지시서(xml)을 만들었다. 지시서가 두가지가있다.

1. 컨트롤러에 의해서 반환되는 값을 가지고 resourceResolver를 이용해서 페이지를 찾는것(/notice/list)
2. tiles가 지시받는 목록의 이름(notice.list)

그리고 어떤페이지들이 필요한지 필요한 목록을 가진것이 tiles.xml이었다면 
그 페이지들을 레이아웃에서 어디에다가 배치할것인지 위치를 정하는 방법을 알아볼것이다.

레이아웃으로 지정된 layout.jsp에다가 
header와 footer 등등을 꽂아넣으려면 tiles가 제공하는 태그 라이브러리를 사용할것이다.
tiles와 관련된 라이브러리는 가져오지않아서 뜨지않는다. maven project이기때문에 tiles라이브러리를 포함할건데 
사이트가서 dependency를 포함하는 방법도있지만 Global Repositories에 있는 tiles-jsp를 선택해준다.

-layout.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="tiles" uri="http://tiles.apache.org/tags-tiles" %>

		...



<body>
    	<!-- header 부분 -->
	<tiles:insertAttribute name="header"/>	//header라는 속성을 layout에다가 페이지에 꽂아달라
  	

	<!-- --------------------------- <visual> --------------------------------------- -->
	<!-- visual 부분 -->
	<tiles:insertAttribute name="visual"/>
	
	<!-- --------------------------- <body> --------------------------------------- -->
	<div id="body">
		<div class="content-container clearfix">

	<!-- --------------------------- aside --------------------------------------- -->
	<!-- aside 부분 -->
	<tiles:insertAttribute name="aside"/>


		
			
	<!-- --------------------------- main --------------------------------------- -->
	<tiles:insertAttribute name="body"/>	
		</div>
	</div>
    <!-- ------------------- <footer> --------------------------------------- -->
	<tiles:insertAttribute name="footer"/>
  </body>

이렇게함으로써 layout페이지를 만들었고 조각난 페이지를 어떻게합칠지 지시도 했었다. 실행을 해야하는데 지금은 안된다. 다음시간에 한가지를 더해야한다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 17 - Tiles ViewResolver 설정하기

Tiles를 이용하기위해서 layout완성했고 layout 페이지를 만들기위해서 라이브러리를 포함시켰다. 남은것은 하나다.
notice.list를 가지고 페이지를 합치는 과정이 필요하다. 그것을 찾아주는녀석이 ViewResolver이다.

Resolving을 하려면 지시서가 어디있는지 알아야한다.

- dispatcher-servlet.xml
<bean
	class="org.springframework.web.servlet.view.UrlBasedViewResolver">
	<property name="viewClass"
		value="org.springframework.web.servlet.view.tiles3.TilesView" />
	<property name="order" value="1" />						// resolver가 두개가있다면 order라는 속성으로 우선순위를 지정해주는것이다.
</bean>

<bean
	class="org.springframework.web.servlet.view.tiles3.TilesConfigurer">
	<property name="definitions" value="/WEB-INF/tiles.xml" />			// tiles가 사용하는 configure를 어디서 찾느냐? 여기서 찾는다.
</bean>



이렇게하고 꼼수파일 index를 실행하게되면 에러가나온다. 클래스가없다는 에러이다. 라이브러리를 하나 추가하도록하자.

javax.servlet jstl라이브러리를 추가하자.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 18 - Tiles 설정에 Wildcard 이용하기

지난시간에 tiles 설정을 끝내고 목록페이지를 볼수있었는데 비효율적인 부분이 보여서 수정하려고한다.

  <definition name="notice.list" template="/WEB-INF/view/customer/inc/layout.jsp">
    <put-attribute name="title" value="공지사항" />
    <put-attribute name="header" value="/WEB-INF/view/inc/header.jsp" />
    <put-attribute name="visual" value="/WEB-INF/view/customer/inc/visual.jsp" />
    <put-attribute name="aside" value="/WEB-INF/view/customer/inc/aside.jsp" />
    <put-attribute name="body" value="/WEB-INF/view/customer/notice/list.jsp" />
    <put-attribute name="footer" value="/WEB-INF/view/inc/footer.jsp" />
  </definition>
   <definition name="notice.detail" template="/WEB-INF/view/customer/inc/layout.jsp">
    <put-attribute name="title" value="Tiles tutorial homepage" />
    <put-attribute name="header" value="/WEB-INF/view/inc/header.jsp" />
    <put-attribute name="visual" value="/WEB-INF/view/customer/inc/visual.jsp" />
    <put-attribute name="aside" value="/WEB-INF/view/customer/inc/aside.jsp" />
    <put-attribute name="body" value="/WEB-INF/view/customer/notice/detail.jsp" />
    <put-attribute name="footer" value="/WEB-INF/view/inc/footer.jsp" />
  </definition>

새로운페이지가 추가된다면  
   <definition name="notice.detail" template="/WEB-INF/view/customer/inc/layout.jsp">
    <put-attribute name="title" value="Tiles tutorial homepage" />
    <put-attribute name="header" value="/WEB-INF/view/inc/header.jsp" />
    <put-attribute name="visual" value="/WEB-INF/view/customer/inc/visual.jsp" />
    <put-attribute name="aside" value="/WEB-INF/view/customer/inc/aside.jsp" />
    <put-attribute name="body" value="/WEB-INF/view/customer/notice/detail.jsp" />
    <put-attribute name="footer" value="/WEB-INF/view/inc/footer.jsp" />
  </definition>
이런형태로 복붙해야되는데 아무래도 아닌것같다.
그래서 사용할 방법은 와일드 카드이다.

  <definition name="notice.*" template="/WEB-INF/view/customer/inc/layout.jsp">		//list가오든 detail이 오든 notice.으로 시작하면 다 합쳐진다.
    <put-attribute name="title" value="공지사항" />
    <put-attribute name="header" value="/WEB-INF/view/inc/header.jsp" />
    <put-attribute name="visual" value="/WEB-INF/view/customer/inc/visual.jsp" />
    <put-attribute name="aside" value="/WEB-INF/view/customer/inc/aside.jsp" />
    <put-attribute name="body" value="/WEB-INF/view/customer/notice/{1}.jsp" />		//첫번째 와일드카드에 해당하는 값이오면 값을 사용할수도있다.
    <put-attribute name="footer" value="/WEB-INF/view/inc/footer.jsp" />
  </definition>

와일드카드를 사용하는 방법은 여러가지가있다. tiles공식문서를 참조해보자

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 19 - Root 페이지들을 위한 Layout 페이지 만들기

지난시간에 와일드카드를 이용해서 패턴을 이용해서 tiles 설정을 해봤는데 목록이라든지 자세한페이지는 잘만들었는데,
index페이지는 헤더와 푸터가 없다. root에 있는 페이지는 어떻게 설정할것인가?

- tiles.xml

<definition name="root.*" template="/WEB-INF/view/inc/layout.jsp">			//*로 안하는 이유는 모든 파일이 다 해당되기 때문이다.
    <put-attribute name="title" value="공지사항" />
    <put-attribute name="header" value="/WEB-INF/view/inc/header.jsp" />
    <put-attribute name="body" value="/WEB-INF/view/notice/{1}.jsp" />
    <put-attribute name="footer" value="/WEB-INF/view/inc/footer.jsp" />
  </definition>

-IndexController.java

public class IndexController implements Controller {

	@Override
	public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception { 
		// TODO Auto-generated method stub
		ModelAndView mv = new ModelAndView("root.index");			// 컨트롤러에서 뷰정보를 반환할때는 root.index를 반환해줘야한다.			
		mv.addObject("data","Hello Spring MVC~");
		//mv.setViewName("/WEB-INF/view/index.jsp");				
		return mv;	
	}		
}

tiles라이브러리 설정하는 법을 알아봤고 spring mvc가 제공하는 프론트 컨트롤러 출력 과 입력을 어떻게 다루는지 알아볼것이다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 20 - 데이터 서비스 클래스(NoticeService) 준비하기

지난시간까지 MVC V를 담당하는 뷰를 만들기위해서 tiles를 사용하는것을 알아봤다.
사용자의 입력을 받아서 처리하는것을 알아보더라도,
임시로 사용할수있는 데이터 서비스 객체가 있어야한다. 오늘은 Data 서비스 객체를 JDBC 수업에서 다뤘던 클래스에서 가져오도록할것이다.

entity,service 패키지를 추가했고 DB에 CREATE query 문도 실행해야한다.


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 21 - 서비스 객체 사용하기

노티스 서비스객체를 가져왔는데 엔티티 클래스도 같이 가져왔다.
이 두가지를 이용해서 데이터베이스에서 데이터 쿼리를 하고 그 결과를 뷰에서 바인딩해서 결과물을 문서해서 볼수있도록 할것이다.

Oracle을 사용해야하므로 라이브러리가 필요하다.
dependecies에서 oracle을 검색하고 최신버전을 추가하도록 하자.

드라이버도 다운로드 받았으니까 데이터베이스를 사용할수있는데, notice service라는 녀석에 객체를 어떻게 생성할지가 문제이다.

일단 사용할때는 noticelistController에서 사용할것이다.

스프링은 di라는 기능을 기본적으로 지원하고 있다. 그래서 한번 생성한 객체를 다양한 컨트롤러가 활용할수있게 갖다 쓸수가있다.

스프링이 제공하고있는 프론트 컨트롤러를 사용하고있다. 그녀석의 이름-servlet.xml 파일에다가 bean이라는 태그로 무언가를 설정했다.
<bean id="/index" class="NoticeController" />			

그러면 여기에 설정했던 내용들은 IOC Container에 담겨진다.  그녀석의 이름-servlet.xml를 스프링이 읽게되면 IOC Container에 담겨진다.
갖다 쓸수도있고 스프링이 dipatcher에서 가져다 쓴다.

<bean class="NoticeService> 라고 한줄을 더 추가하면 IOC Container에 생성된다.  IOC Container에 담겨지면 전역적으로 사용할수있는 객체 보따리이다.
그래서 다른 컨트롤러도 쓸수있다.

문제는 보따리에 있는 녀석을 어떻게 사용할까가 문제이다.

-dispatcher-servlet.xml

<bean id="noticeService" class="com.newlecture.web.controller.service.NoticeService"/>		//패키지명을 입력해야한다.
이렇게하면 IOC Container에 담겨진다. 그럼 이걸 어떻게 쓸거냐? DI를 할것이다.

하는방법은
원래있던 코드인
  <bean id="/notice/list" class="com.newlecture.web.controller.notice.ListController"/>
를

  <bean id="/notice/list" class="com.newlecture.web.controller.notice.ListController"/>
	<property name="noticeService" ref="noticeService">			//name에는 ListController가 가지고있는 세터를 써줘야한다. ref에는 bean객체의 이름을 써줘야한다.
 </bean>



-ListController.java


public class ListController implements Controller{

	private NoticeService noticeService;		//세터가 필요하다. 세터는 클래스 멤버로 존재 가능하다.
	
	public void setNoticeService(NoticeService noticeService) {
		this.noticeService = noticeService;
	}

	@Override
	public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
		ModelAndView mv = new ModelAndView("notice.list");			
		List<Notice> list=noticeService.getList(1, "TITLE", "");			//반환하고있는 내용은 List 를 받아와서
		mv.addObject("list",list);		// 모델로 리스트가 전달되었다.
		
		return mv;	
	}

}


일단 DB에 예시들 넣어보기

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 22 - 서비스 객체 분리하기

스프링을 이용할때에는 엔터프라이즈 형태의 어플리케이션을 만들다보니 서비스라는 클래스를 직접사용하지않는다.
결합력을 낮추는 방식이다. 다시이야기하면 서비스 계층을 나눈다.
오늘은 서비스계층을 나누는 방식을 사용할것이다.

서비스 객체를 사용하는 이유는 결합력을 낮추려고(쉽게 갈아 끼우려고)
 지금은 JDBC (클래스명JDS)를 사용하고있지만 나중에는 MyBatis(클래스명JBS)나 JPA(클래스명JPS)를 사용할수도있다 
내부적으로만 달라진거긴하지만 바꾸게되면서 에러가 발생할것이다. 클래스에 대한이름을 가지고 서비스하면 결합력이 강해진다.
서비스할수있는 내용에만 관심을 갖고있고 구현객체는 관심이없다. 인터페이스를 이용해서 기능에만 포커스를 맞춰져있는 인터페이스를 대신해서 자료형을 쓰게되면

JDS를 바꿨다고 에러가 되지않는다. 꽂아넣을때 인터페이스를 구현해서 꽂아넣으면된다. 
공통분모의 인터페이스만 맞으면 된다.


인터페이스: 구현하는것은 없고 약속을 정하는 녀석

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 23 - 연결정보 분리하기

Notice Service를 사용하고있는 데이터베이스 연결정보도 별도의 클래스를 만들어서 분리할것이다.
연결문자열들이있다.
private String url = "jdbc:oracle:thin:@localhost:1521/xepdb1";
private String uid = "NEWLEC";
private String pwd = "1234";
private String driver = "oracle.jdbc.driver.OracleDriver";
 이거를 자바코드에다가 직접 박아놨는데 이렇게되면 힘든것이 배포하게되었을때(배포할때 바이너리코드로 배포된다) 만약에 패스워드를 주기적으로 바꿔야할때
바이너리로 배포되어있는 것에서 단순하게 비밀번호만바꾸면되는데 소스코드없이 단순히 바꾸는것은 불가능하다.

소스코드변경후에 컴파일하고 재배포해야한다. 데이터베이스가 만약에 위치가 바뀌었다고 하면 소스코드 구해서 변경하고 컴파일 재배포해야한다.
이런방법은 합당하지 않은것 같다.

그래서 변경에대한 부분들을 xml에다가 둘것이다. xml에서 객체화 된 녀석을 DI할것이다. xml파일은 텍스트 그대로 배포되기 때문에 배포에 용이하다.
배포하기위해서  객체로 담을 생각이다. 

-JDBCNoticeService.java

public class JDBCNoticeService implements NoticeService {
	private DataSource dataSource;				//url uid pwd driver 네개를 하나로 묶어서 담을수  있는 인터페이스가 있다. 그것이 데이터 소스이다, 이녀석은 클래스가 아니라 인터페이스다. 이 데이터소스는 실제 객체화할수없다. 
	public void setDataSource(DataSource dataSource) {		//public해서 세터도 만들어 주어야한다.
		this.dataSource = dataSource;			
	}

	public List<Notice> getList(int page, String field, String query) throws ClassNotFoundException, SQLException{
		
		int start = 1 + (page-1)*10;     // 1, 11, 21, 31, ..
		int end = 10*page; // 10, 20, 30, 40...
		
		String sql = "SELECT * FROM NOTICE_VIEW WHERE "+field+" LIKE ? AND NUM BETWEEN ? AND ?";	
		
//		Class.forName(driver);
//		Connection con = DriverManager.getConnection(url,uid, pwd);
		Connection con= dataSource.getConnection();				// 위 의 주석 코드대신에 데이터소스를 만들어서 커넥션을 만들것이다. 커넥션을 만들것이다. 
		PreparedStatement st = con.prepareStatement(sql);
		st.setString(1, "%"+query+"%");

남은것은 하나다. dataSource가 null을 가지고있을텐데 여기다가 어떤객체를 만들것이고 어떻게 꽂아넣어야할지 고민해야한다.

-dispatcher-servlet.xml

<bean id="noticeService" class="com.newlecture.web.service.jdbc.JDBCNoticeService">	//서비스가 세터를 가지고있다. DataSource를 DI할수있는 세터가있다.
	<property name="dataSource" ref="dataSource"/>				//Property로 꽂아넣을것이다.
</bean>

<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">		
	<property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/>		// 세터는 마음대로 할것은 아니고 클래스가 가지고있는 세터를 적어줘야한다. 각각 driverClassName,url,username,passowrd이다.
	<property name="url" value="jdbc:oracle:thin:@localhost:1521/xepdb1"/>		
	<property name="username" value="NEWLEC"/>
	<property name="password" value="1234"/>
</bean> 

pom.xml에서 라이브러리가 추가해야한다. org.spring-jdbc를 추가해주자
	

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 24 - 스프링 설정파일 분리하기

오늘은 spring을 이용할때 쓰는 xml파일을 바꾸려고한다.

xml파일을 WEB-INF 디렉토리안에다가 정해진 이름을 썼었다. 
정해진 위치에다가 뒀었다. 이파일을 다른위치나 다른이름으로 바꾸면 인식이 안되었다.

일반적으로는 이렇게 정해져있는 이름을 쓰지않고 원하는 위치에다가 원하는 파일로 만들어내기도한다.
오늘 할일은 하나로 되어있는 xml파일을 여러개로 나눌것이다. 

WEB-INF 폴더를 생성하고 dispatcher-servlet을 복붙한다.
그리고 하단의 코드만 남기고 지우고 3개를 복사하자.

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:mvc="http://www.springframework.org/schema/mvc"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc
        https://www.springframework.org/schema/mvc/spring-mvc.xsd">

</beans>

이름을 마음대로 정할수있다. 이왕만드는거 이름을 servlet-context, service-context,security-context 로 만들어보자

그러면 굳이 3개로 나눈 이유는 무엇일까?
프로젝트를 한사람이 만드는것이아니라 여러사람들이 역할을 나눠서 만들게 된다. 

하나의 파일로 만들게되면 덮어쓰고 기다리고 동기화과정을 거치게된다. 그래서 따로 역할을 나눠서 작업을 하는것이다.

servlet에는 입출력, 껍데기에 대한설정을 넣고
service는 service에 대한 설정을 넣는다.
security에는 보안 설정을 넣을것이다.


<?xml version="1.0" encoding="UTF-8"?>

<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
  version="4.0"
  metadata-complete="true">
	
	//두개의 파일 지정하는 법
	<listener>											// 스프링이 지원하는 리스너 톰캣또는 세션이 시작 or 끝날때 뭔가 해결할수있는 이벤트를 처리할때 사용하는 녀석
  		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
  	</listener>
  	<context-param>							//Context param이라고 가질수가있다. 아래의 contextConfigLocation을 써서 얘가 리스너를 사용해서 결국 3개의 xml파일을 설정할수 있는것이다.
  		<param-name>contextConfigLocation</param-name>
		<param-value>
			/WEB-INF/spring/service-context.xml
			/WEB-INF/spring/security-context.xml
		</param-value>
	</context-param>

	<servlet>									
		<servlet-name>dispatcher</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>	// web.xml에 설정파일이 어디있다고 말하지 않았어서 기본적인 약속되어있는 위치 약속되어있는 파일명으로 되어있어야한다. 파일 디렉토리를 바꾸면 이야기해줘야한다.
		<init-param>								
			<param-name>contextConfigLocation</param-name>			//세터같은 녀석으로 스펠링이 틀리면안된다.
			<param-value>/WEB-INF/spring/servlet-context.xml</param-value>		// 서블릿 관련된 녀석의 위치를 넣어주면된다.
		</init-param>
	</servlet>

서블릿이라는 녀석이 언제 메모리에 올라가느냐? url 매핑되어있고 첫번째 요청이 오면 올라간다.
우선순위를 높이고 싶다면 
<load-on-startup>숫자</load-on-startup> 을 사용해주면된다

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 25 - 객체 DI를 Annotaion으로 변경하기

이 강의 부터는 조금조금씩 xml 파일로 되어있는 스프링 설정을 Annotaion으로 변경할것이다.
서비스 객체를 사용할때 xml에서 직접 DI할수있었는데, 스프링은 2점대 부터 Annotation을 사용할수 있었다.
어노테이션 방식으로 바꿔보면서 과거 방식에서 요즘 방식으로 바꿔보자

스프링, 자바 어플리케이션 을 사용하는 방식은 크게 두가지가 있다.

1. xml 고전적으로 사용해왔던 텍스트파일을 이용해서 외부설정을하고.
2. Annotation 요즘에 많이 사용하는 방식

두 설정은 장단점이 있다.

스프링에서는 거의 모든것들을 Annotation이나 자바설정으로 바꾸려고한다.
최근에는 자바 설정도아니고 텍스트파일로 가기는 하는데 더 경량화된 property나 yaml으로 더 간단한 방식으로 가고있다.

바뀌어가고있는 과정에서 서비스객체를 DI하는 과정만 Annotation으로 바꿔볼것이다. 그리고 하나씩 하나씩 바꿀것이다.

-servlet-context.xml

			...

<bean id="/notice/list" class="com.newlecture.web.controller.notice.ListController">
	<property name="noticeService" ref="noticeService"/>		//이부분을 지울것이다. 지우면 에러가 발생할것이다. DI가 안되면 NullPointerException 발생
 </bean>
			...


바꿀 부분은 이부분인데 여기서 처럼 xml에서 di를 할수도 있지만 이걸 어노테이션으로도 가능하다.

-ListController.java

public class ListController implements Controller{
		
	@Autowired
	private NoticeService noticeService;
	
								//여기에다가 Autowired를 적을 것이다. 할수있는 이유는 이 소스코드에 손댈수 있기때문이다. 직접만드는 경우 Autowired가 편하다.
	public void setNoticeService(NoticeService noticeService) {
		this.noticeService = noticeService;
	}

	@Override
	public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
		ModelAndView mv = new ModelAndView("notice.list");					//set해서 view에대한 정보를담는다. index.jsp
		List<Notice> list=noticeService.getList(1, "TITLE", "");
		mv.addObject("list",list);		
		return mv;	
	}

}

설정을 더해야한다.

-servlet-context.xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:mvc="http://www.springframework.org/schema/mvc"
	xmlns:context="http://www.springframework.org/schema/context"					//추가
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    	xsi:schemaLocation="http://www.springframework.org/schema/beans
        		https://www.springframework.org/schema/beans/spring-beans.xsd
        		http://www.springframework.org/schema/mvc
        		https://www.springframework.org/schema/mvc/spring-mvc.xsd
        		http://www.springframework.org/schema/context					//추가
        		https://www.springframework.org/schema/context/spring-context.xsd">			//추가

<context:annotation-config/>									//추가 : annotation으로 config를 넣었다  안넣으면 NullpointerException 발생

service-context.xml 도 똑같이 적용했다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 26 - Annotation으로 서비스 객체 생성하기

지난시간에 Annotation을 이용해서 DI를 했었다. 이번에는 서비스객체 자체를 어노테이션으로 생성하도록 바꿀것이다.

-service-context.xml

<bean id="noticeService" class="com.newlecture.web.service.jdbc.JDBCNoticeService">
<!-- 	<property name="dataSource" ref="dataSource"></property> -->
</bean>

지난시간에 한 내용인데 통째로 주석처리를 할것이다. 이렇게한다면 객체가 ioc 컨테이너에 담기지 않는다. 그럼 객체가 ioc컨테이너가 없으니까
불러올것도없어서 오류가 발생할것이다. 컨트롤러에서 오류가 발생할것이다.

오류가 발생하지 않도록하려면 자바코드로 가서 실제 객체가 될수 있도록 설정을 좀 해야한다.

-JDBCNoticeService.java

@Component							// @Component 라는 어노테이션을 붙이게 되면 컨테이너에서 생성해서 담는다. 이렇게 생성하면 컨테이너에 담겨져서 쓸수있다.
public class JDBCNoticeService implements NoticeService {

	@Autowired
	private DataSource dataSource;
	
이렇게 생성하면 문제가 있다. 일단  @Component 를 붙이면 담아줄수 있긴한데 문제는 이 @Component를 발견하려면 어느 범위에 있는것을 뒤져주세요
scan해주세요 스캔범위에 들어가는 클래스들은 객체를 만들어서 ioc한테 담아주세요 그렇게 되어야 한다.

@Component를 찾을수있게 범위를 찾을수있게 패키지를 써줘야한다.
com.newlecture.web.service 범주내에 있는 @Component를 찾아달라고 설정을 해야한다. 어디에다가 설정해야할까?
service-context로가서 @가 붙은 클래스를 찾아서 개체화 할수 있도록 할수있도록 설정할수 있는게 무엇이냐면 <context:component-scan base-package=""> 이 있다.

이것이 뭐냐면 지정해주면 패키지라고 시작하는 패키지 안에있는 모든 클래스를 뒤지게 된다. 스캔해서 @Component를 찾으면 걔를 생성해줄것이다.
그런데 component-scan을 쓰게된다면 당연히 그녀석을 객체화 한다음에 그 안쪽에는 어노테이션이 또 뭐가있는 지 찾아보게된다. 그래서
<context:annotation-config/>는 제거해도된다.	

이렇게 설정하고 실행해보면 잘 돌아간다.
@Component라고 하는녀석은 범용적으로 쓸수있다. 좀 의미론적으로 사용할수 있는것이 있는데 그게 뭐냐면

@Controller, @Service,@Repository 라든지 Component는 구성요소라는 뜻이기 때문에 @Component는 구성요소라는 뜻이기 때문에
Controller Component, Service Component,Repository Component 라서 같은 뜻이기 때문에  @Controller, @Service,@Repository 이런 어노테이션을 쓰는게 더 좋다
코드에서 더 분명하게 역할을 알수있기때문이다.

다음시간에는 컨트롤러도 없애버리고 컨트롤러 만들때 url매핑도 어노테이션으로 바꿔볼것이다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 27 - Annotation으로 URL 매핑하기

지난 시간에는 서비스객체를 어노테이션을 이용해서 객체화해봤다. 오늘은 컨트롤러를 객체화해볼것이다.
servlet-context 에 bean에 controller가있다. 컨트롤러를 어노테이션으로 바꾸고 하단의 코드는 주석처리를 할 것이다.

-servlet-context.xml

<context:annotation-config/>

<bean id="/index" class="com.newlecture.web.controller.IndexController"/>
<bean id="/notice/list" class="com.newlecture.web.controller.notice.ListController"/>
<bean id="/notice/detail" class="com.newlecture.web.controller.notice.DetailController"/>

index controller를 주석처리하면 객체화 되지 않기 때문에 ioc컨테이너에 담기지 않을 것이다.
<!-- <bean id="/index" class="com.newlecture.web.controller.IndexController"/> -->

이것을 어노테이션을 달기위해서 컨트롤러 클래스로 가보자

@Controller							//@Component와 같은 역할인데 

public class IndexController{
	@RequestMapping("/index")					// url매핑할때 어노테이션으로 할때 클래스를 찾는것이다.
	public void aaaa() {
		System.out.println("asdfsdf");
	}

//public class IndexController implements Controller {
//	@Override
//	public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception { 
//		// TODO Auto-generated method stub
//		ModelAndView mv = new ModelAndView("root.index");				
//		mv.addObject("data","Hello Spring MVC~");
//		//mv.setViewName("/WEB-INF/view/index.jsp");				
//		return mv;	
//	}		

}

servlet-context.xml에서도 이녀석을 붙여줘야한다.

-servlet-context.xml

<mvc:annotation-driven/>		//매핑은 이걸로 한다. 사용자 요청을 수반한다, 그리고 역할은 @Controller 는 @Component와 같은 역할을 한다. mapping은 반드시 이녀석으로 해야한다. 


요즘에는 스프링을 이렇게 사용한다. 다음시간에는 컨트롤러의 이름을 바꿀것이다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 28 - HomController 만들기
 
지난시간에  어노테이션에 적용하는 방법에 초점이 맞춰져있었기 때문에 컨트롤러가 컨트롤 형태가 아니게 만들어졌었는데
오늘은 indexController를 컨트롤러 답게 만들어볼것이다.

-IndexController.java
@Controller
public class IndexController{
	@RequestMapping("/index")
	public void aaaa() {
		System.out.println("asdfsdf");
	}


고쳐야 할것이 3가지가 있다.

1. IndexController 컨트롤러가 url 매핑되는것이아니다. 어떻게 위치시켜야할까
2. data라는모델 view라는 페이지를 심었는데 view 가 tiles를 심었는데 이런 view를 심는방법
3.tiles를 이용해서 원래페이지를 매칭시키게 해야한다.

첫번째로 더이상 url이 클래스와 매핑되지않는다. 매핑되는 것은 클래스가 아니라 함수이다. 이 클래스안에는 함수가 하나만왔는데 이제 여러개가 와도된다.

@Controller
public class IndexController{
	@RequestMapping("/index")
	public void aaaa() {			//이름을 막써도 된다 하지만 관련있는 이름으로 바꿔주자
		System.out.println("asdfsdf");
	}
	@RequestMapping("/help")
	public void aaasdfsdaa() {
		System.out.println("asdfsdf");
	}

이런식으로 두개가 와도된다. url매핑된 함수가 두개인것이다.
이제 컨트롤러의 이름을 바꿔야한다. index와 help 둘다 담을수있는 이름으로 바꿀것이다.
HomeController로 이름을 바꿀것이다. 이제는 폴더개념으로 바뀌었기때문에 home에 존재하는 컨트롤러를 담는그릇이라고 봐도 무방하다.

이제 인덱스라고하는 메서드가 있는데 콘솔에서 출력하는게아니라 뷰 정보를 전달해야한다.
public void aaaa() {	
	System.out.println("asdfsdf");
}
view와 모델을 담을 수있는 그릇을 만들어서 반환했는데 

@RequestMapping("/index")
	public String index() {			//반환타입을 view라는 녀석을 반환하기위해서 String으로 바꿈
		return "root.index";			//tiles에서 resolving이 가능해진다.
	}

달라진점은 
1.HomeController가 더이상 직접 컨트롤러가아니고 컨트롤러를 담기위한 컨테이너로써 사용한다,
2. 뷰페이지만들기위해 단순하게 문자열을 반환하면 뷰를 간단하게 찾을수있다.
notice라는 컨트롤러를 한번 이방식대로 만들어보자

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 29 -컨트롤러 정리하기

지난시간에 indexcotroller를 annotation을 썼다 그러면서 중요한점은 RequestMapping 이라는 어노테이션을 썼는데, 컨트롤러를 만드는것이 애매할수도있다.
클래스단위로 url매핑시키는게아니라 함수단위로 url매핑시키니까 실질적인 컨트롤러는 함수가된다. 그러면 함수는 어떻게 정리하는것이 좋을까?

클래스자체가 url매핑되는게 아니라 하나의 클래스안에 모든 컨트롤러 다만들수있다.
이렇게하면 코드량이 너무많아져서 ,객체수가 너무 많아서 관련되어있는것들끼리 묶어서 협업하기도 어렵다.
 notice관련된것은 빼는것이 좋을것같다 .notice에서 사용하는 data service가 있으면 그녀석도 떼는것이 좋다.

view
-customer
	-event
	-faq
	-inc
	-notice
		-detail.jsp
		-list.jsp
-inc
	-index.jsp
이렇게 폴더 구성이 되어있다면 이걸 기준으로 컨트롤러를 생각하면 간단하다. 행위들을 갖고있는 울타리라고 볼수있다. 
대상이라고 하는 녀석들이 갖고있는 기능집합을 묶어줄수있는 녀석들을 단위로 클래스를 만들면된다. notice

customer는 대상에 해당되는 것에 더큰대상이니 패키지로 만들면된다.


@Controller					//객체화하기위해서 꼭 써야한다.
@RequestMapping("/customer/notice/")
public class NoticeController {
	
	@Autowired
	private NoticeService noticeService;
	
	@RequestMapping("list")	
	public String list() {			//문자열을 뷰정보로 반환한다.
		try {
			List<Notice> list=noticeService.getList(1, "TITLE", "");
		} catch (ClassNotFoundException | SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return "notice.list";
	}
	
	@RequestMapping("detail")	
	public String detail() {
		return "notice.detail";
	}

servlet-context.xml에서 index notice detail notice list bean 객체도 삭제해주도록하자.


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 30 -컨트롤러를 위한 Annotation 개념정리

지난시간에 어노테이션을 이용해서 컨트롤러를 바꿔봤는데 아직정리가 안되어있을것같아서 복습하는 시간을 갖도록하자.

어노테이션에서 url과 매핑되는 처리단위는 클래스이다.

어노테이션 구현하기 전 모양은 다음과 같다.

xml으로 구현한 ioc컨테이너를 위한 설정이다.

<bean id="/index" class="com.newlecture.web.controller.IndexController"/>

/index를 수반하는 클래스이다.

pubilc class IndexController implements Controller{	//
	@Override
	public ModelAndView handleRequest(HttpServletRequest ...){
	}
}

/index 라는 사용자 요청이 온다면 그거를 수반하는 클래스가 IndexController이고 Controller를 구현하고있고 약속되어있는 interface함수를 구현해서 사용자 요구에 반응하는 컨트롤러를 구현했다.
하지만 /index가 오게되면 실행되기전에 중간에 조율자가 하나있다. 그것이 스프링이 제공하는 mvc라이브러리이다.
mvc라이브러리는 사용자요청이오면 얘가 요청을 다받고 그 요청들을 적절하게 수행할수있는 컨트롤러를 찾아서 호출해준다.
mvc라이브러리는 Servlet으로 만들어지고 POJO클래스로 만들어진다.

그리고 우리는 바꿨다 어떻게 바꿨냐면 xml설정을 지우고 어노테이션 방식으로 바꿨다.
<!--
<bean id="/index" class="com.newlecture.web.controller.IndexController"/>
<bean id="/hello" class="com.newlecture.web.controller.HelloController"/>
-->

어노테이션 url 매핑은 클래스에 붙는 것이아니라 함수에 붙는다 따라서 클래스를 개별적으로 만들어 줄필요가없다. 그리고 인터페이스가 수반되는 구현도 아니다.
약속되어있는 이름도아니다. 

pubilc class IndexController implements Controller{	
	@RequestMapping()			//함수에 붙는다.
	public ModelAndView handleRequest(HttpServletRequest ...){
	}
}
그냥 mvc가 스캐닝을해서 @붙어있는 녀석이 있으면 이름과 상관없이 @가 붙어있는 함수로 호출하게 된다.
url이있으면 url에 맞는 딱지가 붙어있는 함수로 호출하는 방법으로 하기때문에 이전에 인터페이스라는 제약이없고 클래스당 url 매핑을 하는것도 아니기 때문에
오히려 url매핑을 하나의 클래스로 묶어서 매핑을 하는 경우가 생긴다. 


@Controller
pubilc class IndexController implements Controller{	
	@RequestMapping()			//함수에 붙는다.
	public ModelAndView handleRequest(HttpServletRequest ...){
	}
	@RequestMapping()			//함수에 붙는다.
	public ModelAndView handleRequest(HttpServletRequest ...){
	}
}

Controller를 생성하기위해서 원래는 (implements Controller)
@Controller라는 어노테이션을 사용하게된다. 컨트롤러 클래스안에있는 url매핑하게된다. 대신에 이 컨트롤러가 실제로 인식이되고 또 객체가 될수 있어야하기 떄문에
이 컨트롤러를 찾기위한 설정이 하나더 필요하다. component-scan이라고 해서 컨트롤러 클래스가 존재하는 패키지명을 설정함으로 찾아나설수있게끔 설정했다.
url매핑은 이설정으로는 불가능한다. 이 설정은 클래스를 로드하는, 클래스에 붙어서 클래스를 객체화하는 그런 스캐닝이다.

<context:component-scan base-package=".." />

이 안쪽에 RequestMapping 이라는 설정을 사용하려면  또다른 설정도 해줘야한다.

<mvc:annotation-driven/>

이 두가지 설정중에서 하나만 빠져도 문제가 발생한다.


그래서 만들어진 컨트롤러의 모양이다.

@Controller
public class HomeController{		
	
	@RequestMapping("/index")			//함수에다가 붙였다
	public String index() {			// 함수라는 것은 아무이름을 써도된다. url 매핑했던 /index 가 중요하다. 이름자체가 매핑에서 붙이는게 중요하다. 관리를 위해서라도
		System.out.println("index 요청있었다)	// 함수의 반환 타입은 아무렇게나 해도된다. void도 가능 String도 된다. void라고하면 오류아닌 오류가 발생할수도있다. 화면에 출력할 문서정보가 없기때문에 ViewResolver라는 녀석이 찾을것이다. 위치+매핑되어있는녀석+.jsp 붙여서 뷰페이지를  찾다가 오류가 날것이다. 하지만 서버상에서는 정상적으로 동작할것이다. 
	}					// 만약에 viewResolver가 없다면 더 큰 문제가 발생한다.

	@RequestMapping("/hello")
	public String index() {
		System.out.println("hello 요청있었다)
	}
}	

반환타입을 void로 설정하면 생기는 일

Front Controller의 역할은 재호출이다. 
1. request "/index" 라는 사용자요청을 받으면
2. Front Controller는 서블릿이기 때문에 request 와 response 두개가 가지고있는 인자를 가지고있는 함수를 호출을 할것이다.
3.거기서 우리가 만든 녀석을 호출할것이다. 만약에 Front Controller가 우리가 url매핑된 클래스를 찾을수 없어서 설정에 아무리봐도 찾을수없으면 실제로 컨트롤러를 찾을수없기때문에 404를 반환한다.

3-1.만약에 설정되어있는 컨트롤러가 있다면 url매핑도 있다면 요청이오면 컨트롤러가 있으니까 다시호출하는 작업을 하는데 돌려줄게 void니까 돌려줄 내용이없어서 Controller 가없는게 아니라 돌려줄 내용이없어서 404가 날것이다.

얘가 view를 제공안해도 404 컨트롤러가 없어도 404가 난다.

우리는 void로 안했다. tiles를 쓰고있기떄문에 string을 반환해서 view정보를 반환하고 tilesResolver가 그걸찾아서 실행해서 결과값으로 문서를 전달하는 그런 방식을 사용했었다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 31 - 문서 출력방법 4가지 @ResponseBody

지난시간에는 url 매핑하기위한 방법을 알아봤다.
컨트롤러에서 출력하는 방법도 달라질것같다. 스프링을 이용해서 출력하는 방법이 4가지가있다. 


1. 서블릿객체를 얻어서 문자열 출력하기
2. @ResponseBody 설정을 통한 문자열 출력하기
3. ResourceViewResolver를 이용한 문서 출력하기
4. TilesViewResolver를 이용한 문서 출력하기

지난시간에는 view라는것을 문서화하고 그 문서화된 내용을 resolver로 통해서 출력하는것을 다뤄봤다.

우리가 많이쓰는 옵션은 또 뭐냐면 단순하게 문자열을 만들어서 출력하고 싶을때도 있다.
그럴경우에는 방법이 두가지가있다. servlet객체를 이용해서 얻어가지고 출력하는 방법이있고,
또는 Response body라고한 설정을 통해서 문자를 출력하는 방법이있다.

4가지중에서 선택적으로 잘사용할수있어야한다.

가장 기본적인 방법부터 알아보자

@Controller
@RequestMapping("/")
public class HomeController{
	
	@RequestMapping("index")
	public void index() {					//void를 반환하니 리턴값이없다. 이렇게되면 Resolver를 사용하지 않겠다는 뜻이다.
		
	}

그러면 어떻게 출력할까?

FrontController가 스프링이 제공하고있는 컨트롤러인데 이녀석을 통해서 요청이 걸러서 온다 . 이 컨트롤러가 호출된 함수명을 보는것이 아니라
@RequestMapping이라고 하는 주석에 달려있는 녀석을 보고 괄호안에있는 녀석을 호출해준다.

만약에 컨트롤러에서 매개값을 안주면 그냥 호출하지만, 
ex)

-Controller
public void index() {
	
}

-Front Controller
void service(HttpRequest request, Http... response){
	method.invoke();
}



매개값을 선언해주면  front Controller에서 호출되기전에 값이 있는지 확인해보고 그값을 제공할수있는지 확인해본 다음 제공할수있으면 Controller가 달라고 하니까
 FrontController가 갖고있는 객체를 참조(전달)하기도 한다. 
FrontController
ex)

-Controller
public void index(HttpServletResp) {	<--------------------		
	PrintWriter out = response.getWriter();	l
	out.println("Welcome");			l
						l
}						l
						l
-Front Controller					l
void service(HttpRequest request, Http... response){	l		// 같은 response객체를 받으면서 그걸이용해서 출력도 가능하다.	
	method.invoke(response);					// 객체가 가지고있는 writer를 가지고 출력을 하게되면은 출력이라고하는 문서를 굳이 resolver로 반환하지않고 출력해볼수 있다.
}								// 이렇게 출력되게되면 이제 출력될값이 출력버퍼에 들어가게되고 이것이 void를 반환 할지라도 Controller에 출력되는 값을 채웠기때문에 출력된다.


이게바로 첫번째 방법이다.
이렇게 과거에 서블릿이라고하는것을 사용했을때 처럼 내가 필요한것이있으면 Controller의 클래스의 매개변수로 에 Request 나 Response를 선언해주면된다.
그럼 프론트 컨트롤러가 이걸 넘겨준다. 참조를가지고 입출력이가능하다. viewResolver없이 어떤 page를 준비하지않고 직접출력하려면 이렇게 해도된다.

하지만 스프링은 더편한방법을 제공하고있다.
서블릿객체를 얻어서 활용할수도있지만 문서가 필요없고 Hello Index를 출력해보고싶으면

public void index(HttpServletResp){					//반환형을 String으로 바꾸고
	return "Hello Index";					//출력하고 싶은 문자열을 반환하면된다.
}

이렇게하면 문제가 반환하는것들을 view라고 생각하고 view와 관련된Resolver에서 이이름에 관련된 페이지를 찾든 Tiles정보를 얻는 그렇게 될것이다.
우리가 반환하는 문자열은  문자열자체가 사용자에게 가길원한다.라고하면 어노테이션을 써야한다.
@ResponseBody : 리턴하는 녀석은 그자체가 Responsebody이다.  viewResolver를 사용하지말고 이자체를 사용자에게 보내라 이런 말이다.

ex)
@ResponseBody
public String index() {
	return "Hello Index";
}
	


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Spring MVC (스프링 웹 MVC) 강의 32 - @RestController와 한글출력 설정

restController는 문서를 만들어서 제공해주는것이아니라 주로 데이터를 제공해주는것이 주된 역할을 하는 컨트롤러이다.
이걸 쓰면서 문제가 되는 점이 한글 출력이 문제가 된다.
한글 출력이 문제가없도록 어떤걸 설정해야하는지 알아보자.

프로젝트를 진행하다보면 스크립트를 만드는 사람들에게 문서를 줄것이아니라 데이터를 줘야되는 경우가 발생한다.
그럴경우에는 컨트롤러에가서 controller에다가 마우스오른쪽클릭해서 클래스를 추가할것이다.

패키지명은 com.newlecture.web.controller.api이 될것이다. 데이터를 제공해주는 그런 컨트롤러이다.
NoticeController라고 이름을 정해보자 기존에 컨트롤러와 똑같이 작성할수 있긴 한데
클래스 위에 @Controller 라고 어노테이션을 붙이면 일반적으로 문서를 기반으로  하는 반환값을 갖고있는 컨트롤러이다.

@RestController 라고 하면 좀 특화된 컨트롤러이다. 출력되는것 자체가 rest-ful 한 결과물을 나타내는 클래스라고 할수있다.

-NoticeController.java

package com.newlecture.web.controller.api;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController							
@RequestMapping("/api/notice/") 		//notice에 대한 데이터의 목록을 주는 식이다.
public class NoticeController {
		
	@RequestMapping("list")
	public String list() {
		

		return "notice list";			//@RestController는 여기에 반환하는 값을 반환하게된다.
	}	//NoticeController noticeController= new Notice Controller라고 하는 녀석을 담을것이다. 뽑아오기위해서 변수선언하듯이 앞글자가 소문자된 noticeController 를 키값으로 가져온다.
}		// xml 형식으로 표현하게되면 <bean id= "noticeController" class=".....NoticeController > 현재 noitceController가 있어서 모호해서 에러가 나는 것이다.

이렇게 실행하면 충돌 에러가 난다. 왜 에러가 나냐면

식별자 붙일때 묵시적으로 지정하지않아서 오류가나는것이다. 그러면 @RestController 뒤에다가 이름을 붙여주면된다. @RestController("apiNoticeController")
이렇게하면 묵시적으로 부여해서 충돌이 나지않을것이다.

자바스크립트 개발자에게 데이터를 제공할때는 RestController를 만들어서 제공할것인데 공지사항이라는 글자를 한글로 바꾸어보자
return "notice list";	 에서 notice를 공지사항으로 바꾸자 한글이 깨졌다. 어떻게 해결할것이냐면 우리가 가야할곳은 servlet-context를 클릭해서 열어보면
annotation:driven 이 있는데 annotation:driven 은 우리가 작성하고있는 url과 관련된 요청이 있을때 어노테이션을 통해서 수반될수 있도록 해주는 그런녀석이다.
<mvc:annotation-driven/>이 이렇게 닫혀있는데 열어줘야한다.

열고 다음과 같이 설정해주자

<mvc:annotation-driven><!-- 역할은 @Controller 는 @Component와 같은 역할을 한다. mapping은 반드시 이녀석으로 해야한다.  -->
		<mvc:message-converters> <!-- 어노테이션으로 요청을하고 그결과를  @ResponseBody형식으로 반환된다면 그것을 가로채기해서 그거를 변환해주는 기능을 담당한다. -->
		<bean class="org.springframework.http.converter.StringHttpMessageConverter">
			<property name="supportedMediaTypes">
				<list>
					<value>text/html;charset=UTF-8</value>
				</list>
			</property>
		</bean>
		</mvc:message-converters>
	</mvc:annotation-driven>

이걸 가져다 써도 에러가 날수도있다. 코드를 다른데서 작성한다음에 가져와야한다. 

restController를 활용해서 자바스크립트를 가지고 프론트에서 개발하는 사람들이 따로있다하면 제공해주는 것을 배웠고
다음시간에는 자동으로 json형태로 반환해주지 않기때문에 json형태로 반환하는것을 배울것이다. 

notice객체를 json형태로 자동반환해주는 객체를 만들것이다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




